import{_ as i}from"./chunks/ArticleMetadata.BuBbIslv.js";import{_ as s,m as d,a as c,u as g,B as p,e as o,x as u,ah as h,o as r,p as m,q as _}from"./chunks/framework.Bi-mNMmX.js";import"./chunks/theme.ulrGMYOD.js";const x=JSON.parse('{"title":"堆","description":"","frontmatter":{"title":"堆","author":"Noah","date":"2024/07/04 16:32","categories":["JVM"],"tags":["Java","JVM","JDK"]},"headers":[],"relativePath":"courses/java/advance/03-JVM/06-堆.md","filePath":"courses/java/advance/03-JVM/06-堆.md","lastUpdated":1720612269000}'),v={name:"courses/java/advance/03-JVM/06-堆.md"},b=o("h1",{id:"堆",tabindex:"-1"},[u("堆 "),o("a",{class:"header-anchor",href:"#堆","aria-label":'Permalink to "堆"'},"​")],-1),M=h('<nav class="table-of-contents"><ul><li><a href="#特点">特点</a></li><li><a href="#结构">结构</a></li><li><a href="#垃圾收集-garbage-collection">垃圾收集(Garbage Collection)</a></li><li><a href="#堆内存管理参数">堆内存管理参数</a></li></ul></nav><p>在Java中，堆(Heap)是JVM内存模型中的一个重要区域，用于存储所有对象的实力和数组。堆是Java应用程序中最大的一块内存区域，由所有线程共享，负责动态分配内存。</p><h2 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h2><ol><li><strong>线程共享:</strong> 堆内存是所有线程共享的，任何线程都可以访问堆中的对象。</li><li><strong>动态分配:</strong> 堆内存用于动态分配对象的内存空间，对象的生命周期由垃圾收集器管理。</li><li><strong>自动内存管理:</strong> JVM通过垃圾收集器自动管理堆内存分配和回收，无需程序员手动干预。</li></ol><h2 id="结构" tabindex="-1">结构 <a class="header-anchor" href="#结构" aria-label="Permalink to &quot;结构&quot;">​</a></h2><p>Java堆通常分为三个主要区域：新生代(Young Generation)、老年代(Old Generation) 和永久代/元空间(Permanent Generation / Metaspace)。</p><div class="warning custom-block"><p class="custom-block-title">注意💡</p><p>在JDK1.6之前，一直采用的永久代，之后在JDK1.7中有一个理念叫做&quot;去永久代&quot;。在JDK1.7中，永久代慢慢退化，直到JDK1.8之后的版本，彻底将永久代替换为元空间。</p></div><ol><li><p><strong>新生代(Young Generation)</strong> 新生代用于存储新创建的对象，大部分对象在新生代中创建并很快被垃圾收集器回收。新生代分为三个区域:</p><ul><li><strong>伊甸区(Eden):</strong> 新对象在Eden区分配内存。</li><li><strong>两个幸存区(Survivor0和Survivor1):</strong> 用于在Minor GC(年轻代垃圾回收)时存活对象的复制。</li></ul><p>在Eden区和两个Survivor区之间进行对象的复制和移动，以便于在Minor GC时回收内存。</p></li><li><p><strong>老年代(Old Generation):</strong> 老年代用于存储生命周期较长的对象。经过多次Minor GC 仍然存活的对象会从新生代晋升到老年代。当老年代内存不足时，触发 Major GC(老年代垃圾回收)，这通常是耗时较长的一次回收。</p></li><li><p><strong>永久代/元空间(Permanent Generation / Metaspace):</strong> 永久代(在Java 8之前)或元空间(从Java 8 开始) 用于存储类的元数据、方法信息、常量池和JIT编译后的代码。</p><ul><li><strong>永久代(PernGen):</strong> 存储类信息、常量、静态变量等。</li><li><strong>元空间(Meataspace):</strong> 从Java 8开始，取代永久代，使用本地内存存储类的元数据。</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240704182701.jpg" alt=""></p><h2 id="垃圾收集-garbage-collection" tabindex="-1">垃圾收集(Garbage Collection) <a class="header-anchor" href="#垃圾收集-garbage-collection" aria-label="Permalink to &quot;垃圾收集(Garbage Collection)&quot;">​</a></h2><p>堆内存由垃圾收集器管理，垃圾收集器负责回收不再使用的对象，释放内存。垃圾收集器主要分为两类：</p><ul><li><strong>Minor GC:</strong> 回收新生代内存，频率较高，但速度较快。</li><li><strong>Major GC:</strong> 回收新生代内存，频率较低，但耗时较长，通常是 Minor GC 的10倍以上。</li></ul><div class="warning custom-block"><p class="custom-block-title">注意💡</p><p>值得注意的是 在JVM中还有一个叫做Full GC的垃圾回收器，它的作用范围是整个堆内存。</p></div><table tabindex="0"><thead><tr><th>特效</th><th>Minor GC</th><th>Major GC</th><th>Full GC</th></tr></thead><tbody><tr><td>目标区域</td><td>主要回收新生代</td><td>主要回收老年代</td><td>回收整个堆内存</td></tr><tr><td>触发条件</td><td>新生代内存不足</td><td>老年代内存不足</td><td>内存紧张，老年代空间不足</td></tr><tr><td>执行频率</td><td>较高</td><td>较低</td><td>较低</td></tr><tr><td>性能影响</td><td>耗时最短的GC，频率最高</td><td>比 Minor GC 耗时长，但低于 Full GC</td><td>最耗时，暂停所有应用线程</td></tr><tr><td>影响范围</td><td>主要针对新生代</td><td>主要针对老年代</td><td>涉及新生代、老年代和永久代/元空间</td></tr></tbody></table><h2 id="堆内存管理参数" tabindex="-1">堆内存管理参数 <a class="header-anchor" href="#堆内存管理参数" aria-label="Permalink to &quot;堆内存管理参数&quot;">​</a></h2><p>在 Java 中，可以通过以下 JVM 参数来配置堆内存的大小和管理策略：</p><ul><li><strong><code>-Xms</code>:</strong> 设置堆内存初始大小。</li><li><strong><code>-Xmx</code>:</strong> 设置堆内存最大大小。</li><li><strong><code>-XX:NewRation</code>:</strong> 设置新生代和老年代的比率。</li><li><strong><code>-XX:SurvivorRation</code>:</strong> 设置 Eden 区和 Survivor 区的比率。</li><li><strong><code>-XX:MetaspaceSize</code>:</strong> 设置元空间的初始大小(从 Java 8 开始)。</li><li><strong><code>-XX:MaxMetaspaceSize</code>:</strong> 设置元空间的最大大小(从 Java 8 开始)。</li></ul>',17);function J(t,C,G,f,V,k){const n=i,l=d("ClientOnly");return r(),c("div",null,[b,g(l,null,{default:p(()=>{var a,e;return[(((a=t.$frontmatter)==null?void 0:a.aside)??!0)&&(((e=t.$frontmatter)==null?void 0:e.showArticleMetadata)??!0)?(r(),m(n,{key:0,article:t.$frontmatter},null,8,["article"])):_("",!0)]}),_:1}),M])}const N=s(v,[["render",J]]);export{x as __pageData,N as default};
