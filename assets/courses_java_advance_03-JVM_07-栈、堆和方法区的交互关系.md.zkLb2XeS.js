import{_ as h}from"./chunks/ArticleMetadata.BqQPtrzx.js";import{_ as p,m as k,a as r,u as d,B as o,e as l,x as c,ah as g,o as n,p as y,q as A}from"./chunks/framework.Bi-mNMmX.js";import"./chunks/theme.NLG9-6OP.js";const j=JSON.parse('{"title":"栈、堆和方法区的交互关系","description":"","frontmatter":{"title":"栈、堆和方法区的交互关系","author":"Noah","date":"2024/07/04 18:35","categories":["JVM"],"tags":["Java","JVM","JDK"]},"headers":[],"relativePath":"courses/java/advance/03-JVM/07-栈、堆和方法区的交互关系.md","filePath":"courses/java/advance/03-JVM/07-栈、堆和方法区的交互关系.md","lastUpdated":1720165726000}'),C={name:"courses/java/advance/03-JVM/07-栈、堆和方法区的交互关系.md"},D=l("h1",{id:"栈、堆和方法区的交互关系",tabindex:"-1"},[c("栈、堆和方法区的交互关系 "),l("a",{class:"header-anchor",href:"#栈、堆和方法区的交互关系","aria-label":'Permalink to "栈、堆和方法区的交互关系"'},"​")],-1),u=g(`<nav class="table-of-contents"><ul><li><a href="#栈-stack">栈(Stack)</a></li><li><a href="#堆-heap">堆(Heap)</a></li><li><a href="#方法区-method-area">方法区(Method Area)</a></li><li><a href="#三者的交互关系">三者的交互关系</a></li><li><a href="#示例">示例</a></li><li><a href="#总结">总结</a></li></ul></nav><p>在 JVM 中，栈、堆和方法区是三种关键的内存区域，它们共同协作以支持Java程序的执行。理解它们之间的交互关系有助于深入掌握 Java 的运行机制和优化程序性能。</p><h2 id="栈-stack" tabindex="-1">栈(Stack) <a class="header-anchor" href="#栈-stack" aria-label="Permalink to &quot;栈(Stack)&quot;">​</a></h2><ul><li>**作用: ** 栈主要用于存储局部变量、方法调用信息和操作数。每个线程都有自己的栈，即线程私有。</li><li><strong>内容:</strong><ul><li><strong>局部变量表:</strong> 存储方法中的局部变量和参数。</li><li><strong>操作数栈:</strong> 用于字节码指令执行时的临时数据存储。</li><li><strong>栈帧:</strong> 每个方法调用对应一个栈帧，包含局部变量表、操作数栈和方法返回地址。</li></ul></li></ul><h2 id="堆-heap" tabindex="-1">堆(Heap) <a class="header-anchor" href="#堆-heap" aria-label="Permalink to &quot;堆(Heap)&quot;">​</a></h2><ul><li>**作用: ** 堆是所有线程共享的内存区域，用于存储所有对象实例和数组。堆内存由垃圾收集器管理。</li><li><strong>内容:</strong><ul><li><strong>对象实例:</strong> 所有新创建的对象和数组都分配在堆中。</li><li><strong>新生代和老年代:</strong> 堆分为新生代和老年代，新生代又分为Eden区和两个Survivor区。</li></ul></li></ul><h2 id="方法区-method-area" tabindex="-1">方法区(Method Area) <a class="header-anchor" href="#方法区-method-area" aria-label="Permalink to &quot;方法区(Method Area)&quot;">​</a></h2><ul><li>**作用: ** 用于存储类的信息、常量、静态变量和即时编译后的代码</li><li><strong>内容:</strong><ul><li><strong>类信息:</strong> 包括类的名称、父类、接口、字段和方法等元数据。</li><li><strong>运行时常量池:</strong> 存储编译期生成的各种字面量和符号引用。</li><li><strong>静态变量:</strong> 存储类的静态字段。</li><li><strong>即时编译后的代码:</strong> JIT编译器将不分字节码编译为本地代码，存储在方法区中。</li></ul></li></ul><h2 id="三者的交互关系" tabindex="-1">三者的交互关系 <a class="header-anchor" href="#三者的交互关系" aria-label="Permalink to &quot;三者的交互关系&quot;">​</a></h2><ol><li><p><strong>对象创建和方法调用:</strong></p><ul><li>当一个方法调用时，会在栈中创建一个新的栈帧。方法的局部变量和参数存储在局部变量表中。如果方法中创建了新的对象，则该对象会在堆中分配内存，并且对象引用存储在局部变量表中。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Example</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> method</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        MyObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> MyObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>在上述代码中:</p><ul><li><code>method</code> 方法被调用时，会在栈中创建一个栈帧。</li><li><code>obj</code> 引用存储在局部变量表中，而 <code>MyObject</code> 实例存储在堆中。</li></ul></li><li><p><strong>类的加载和初始化:</strong></p><ul><li>当第一次使用一个类时，类加载器会将类的字节码加载到方法区，创建该类的运行时数据结构，包括类信息、静态变量和运行时常量池。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> staticVar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>在上述代码中：</p><ul><li><code>Myclass</code> 类加载时，其类信息和 <code>staticVar</code> 静态变量会存储在方法区中。</li><li>如果 <code>MyClass</code> 的静态方法或字段被调用，会在栈中创建相应的栈帧来执行。</li></ul></li><li><p><strong>垃圾收集:</strong></p><ul><li>垃圾收集器会在堆中回收不在使用的对象，当栈中的引用变量不在引用某个对象时，垃圾收集器会将该对象标记为可回收。</li><li>方法区中的类信息和静态变量也可能被垃圾收集器回收(如类卸载)，但这通常发生在类加载器被回收时。</li></ul></li></ol><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> InteractionExample</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> myClass</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        myClass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">method</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> staticVar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> method</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> localVar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        MyObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> MyObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> MyObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> instanceVar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 30</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>在上述代码中:</p><ul><li><strong>栈:</strong><ul><li><code>main</code> 方法调用时，创建一个栈帧，<code>args</code> 存储在局部变量表中。</li><li><code>myClass</code> 引用指向堆中的 <code>MyClass</code> 实例。</li><li><code>method</code> 方法调用时，创建一个新的栈帧，<code>localVar</code> 和 <code>obj</code> 引用存储在局部变量表中。</li></ul></li><li><strong>堆:</strong><ul><li><code>new MyClass()</code> 和 <code>new MyObject()</code> 分别在堆中分配内存，存储相应的对象实例。</li></ul></li><li><strong>方法区:</strong><ul><li><code>MyClass</code> 和 <code>MyObject()</code> 的类信息、静态变量和方法存储在方法区中。</li><li><code>staticVar</code> 是 <code>MyClass</code> 的静态变量，存储在方法区中。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240704195630.jpg" alt=""></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>栈、堆和方法区在JVM内存模型中各司其职，协同工作。栈主要管理方法调用和局部变量，堆负责对象的存储和内存分配，而方法区则存储类信息和静态变量。三者通过对象引用和方法调用等机制紧密交互。</p>`,17);function F(s,m,B,b,_,E){const t=h,e=k("ClientOnly");return n(),r("div",null,[D,d(e,null,{default:o(()=>{var i,a;return[(((i=s.$frontmatter)==null?void 0:i.aside)??!0)&&(((a=s.$frontmatter)==null?void 0:a.showArticleMetadata)??!0)?(n(),y(t,{key:0,article:s.$frontmatter},null,8,["article"])):A("",!0)]}),_:1}),u])}const V=p(C,[["render",F]]);export{j as __pageData,V as default};
