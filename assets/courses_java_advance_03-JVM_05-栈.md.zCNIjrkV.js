import{_ as h}from"./chunks/ArticleMetadata.Ba4icgGF.js";import{_ as p,m as k,a as r,u as d,B as o,e as l,x as c,ah as g,o as n,p as A,q as y}from"./chunks/framework.Bi-mNMmX.js";import"./chunks/theme.--nR5Zd2.js";const S=JSON.parse('{"title":"栈","description":"","frontmatter":{"title":"栈","author":"Noah","date":"2024/07/03 19:26","categories":["JVM"],"tags":["Java","JVM","JDK"]},"headers":[],"relativePath":"courses/java/advance/03-JVM/05-栈.md","filePath":"courses/java/advance/03-JVM/05-栈.md","lastUpdated":1720165726000}'),D={name:"courses/java/advance/03-JVM/05-栈.md"},u=l("h1",{id:"栈",tabindex:"-1"},[c("栈 "),l("a",{class:"header-anchor",href:"#栈","aria-label":'Permalink to "栈"'},"​")],-1),C=g(`<nav class="table-of-contents"><ul><li><a href="#结构">结构</a></li><li><a href="#特点">特点</a></li><li><a href="#工作原理">工作原理</a></li><li><a href="#栈内存溢出">栈内存溢出</a></li></ul></nav><p>在Java中，栈(Stack)是每个线程独立有的内存区域，用于存储局部变量、方法调用、信息和操作数等。Java栈也被称为虚拟机栈(Java Virtual Machine Stack)。它的主要作用是管理方法调用和执行。</p><h2 id="结构" tabindex="-1">结构 <a class="header-anchor" href="#结构" aria-label="Permalink to &quot;结构&quot;">​</a></h2><p>Java栈是由多个栈帧(Stack Frame)组成的。每当一个方法被调用时，JVM会创建一个新的栈帧，并将其压入栈顶。方法执行完毕后，栈帧会从栈顶弹出。栈帧包括以下几个部分：</p><ol><li><strong>局部变量表(Local Variable Array)</strong><ul><li>存储方法的局部变量，包括方法参数和方法内定义的变量。</li><li>使用索引访问局部变量。</li></ul></li><li><strong>操作数栈(Operand Stack)</strong><ul><li>用于执行字节码指令时，临时存储操作数。</li><li>通过出栈和入栈操作进行计算。</li></ul></li><li><strong>动态链接(Dynamic Linking)</strong><ul><li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，用于支持方法调用和返回。</li></ul></li><li><strong>方法返回地址(Return Address)</strong><ul><li><strong>方法返回指令:</strong> 执行引擎遇到一个方法返回的字节码指令，这时候有可能会有返回值传递给上层的方法调用者，这种退出方式称为正常完成出口</li><li><strong>异常退出:</strong> 在方法执行过程中遇到了异常，并且没有处理这个异常，就会导致方法退出。</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240704181803.jpg" alt=""></p><h2 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h2><ol><li><strong>线程私有:</strong> 每个线程都有自己的栈，栈与线程生命周期相同，线程结束时栈也会被销毁。</li><li><strong>栈内存小:</strong> 栈的大小通常较小，默认大小可以通过 <code>-Xss</code> 参数设置。</li><li><strong>自动内存管理:</strong> 栈内存由JVM自动管理，无需手动分配和释放。</li></ol><h2 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h2><p>当一个方法被调用时，会创建一个新的栈帧，并将其放入栈顶， 例如：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> StackExample</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(result);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> sum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> b;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> sum;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>执行过程如下:</p><ol><li><strong>main方法调用</strong><ul><li>创建 <code>main</code> 方法栈帧，压入栈顶。</li><li><code>main</code> 方法内的局部变量 <code>args</code> 和 <code>result</code> 存储在局部变量表中。</li></ul></li><li><strong>add方法调用</strong><ul><li>创建 <code>add</code> 方法的栈帧，压入栈顶。</li><li><code>add</code> 方法的参数 <code>a</code> 和 <code>b</code> 存储在局部变量表中。</li></ul></li><li><strong>add方法的执行</strong><ul><li>在操作数栈中进行计算，将结果存储在局部变量 <code>sum</code> 中。</li></ul></li><li><strong>add方法返回</strong><ul><li><code>add</code> 方法执行完毕，栈帧从栈顶弹出，将返回值压入操作数栈。</li></ul></li><li><strong>main方法继续执行</strong><ul><li>从操作数栈中获取返回值，并存储在局部变量 <code>result</code> 中。</li></ul></li><li><strong>main方法返回</strong><ul><li><code>main</code> 方法执行完毕，栈帧从栈顶弹出</li></ul></li></ol><h2 id="栈内存溢出" tabindex="-1">栈内存溢出 <a class="header-anchor" href="#栈内存溢出" aria-label="Permalink to &quot;栈内存溢出&quot;">​</a></h2><p>由于栈的大小是有限的，当递归调用过深，或方法调用链过长，可能会导致栈内存溢出，抛出 <code>StackOverFlowError</code> 异常。例如：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> StackOverflowExample</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">        recursiveMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> recursiveMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">        recursiveMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div>`,16);function F(s,m,B,E,v,_){const t=h,e=k("ClientOnly");return n(),r("div",null,[u,d(e,null,{default:o(()=>{var i,a;return[(((i=s.$frontmatter)==null?void 0:i.aside)??!0)&&(((a=s.$frontmatter)==null?void 0:a.showArticleMetadata)??!0)?(n(),A(t,{key:0,article:s.$frontmatter},null,8,["article"])):y("",!0)]}),_:1}),C])}const J=p(D,[["render",F]]);export{S as __pageData,J as default};
