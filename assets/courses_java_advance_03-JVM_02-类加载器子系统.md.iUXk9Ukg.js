import{_ as o}from"./chunks/ArticleMetadata.Ba4icgGF.js";import{_ as r,m as d,a as h,u as c,B as p,e as l,x as k,ah as g,o as e,p as u,q as C}from"./chunks/framework.Bi-mNMmX.js";import"./chunks/theme.--nR5Zd2.js";const q=JSON.parse('{"title":"类加载器子系统","description":"","frontmatter":{"title":"类加载器子系统","author":"Noah","date":"2024/07/03 15:32","categories":["JVM"],"tags":["Java","JVM","JDK"]},"headers":[],"relativePath":"courses/java/advance/03-JVM/02-类加载器子系统.md","filePath":"courses/java/advance/03-JVM/02-类加载器子系统.md","lastUpdated":1720010212000}'),_={name:"courses/java/advance/03-JVM/02-类加载器子系统.md"},y=l("h1",{id:"类加载器子系统",tabindex:"-1"},[k("类加载器子系统 "),l("a",{class:"header-anchor",href:"#类加载器子系统","aria-label":'Permalink to "类加载器子系统"'},"​")],-1),A=g(`<nav class="table-of-contents"><ul><li><a href="#类加载器-class-loader">类加载器(Class Loader)</a></li><li><a href="#类加载过程">类加载过程</a><ul><li><a href="#_1-加载-loading">1.加载(Loading)</a></li><li><a href="#_2-连接-linking">2.连接(Linking)</a></li><li><a href="#_3-初始化-initialization">3.初始化(Initialization)</a></li></ul></li><li><a href="#类加载过程示例">类加载过程示例</a></li><li><a href="#双亲委派机制">双亲委派机制</a><ul><li><a href="#委派的过程">委派的过程</a></li><li><a href="#优点">优点</a></li></ul></li></ul></nav><h2 id="类加载器-class-loader" tabindex="-1">类加载器(Class Loader) <a class="header-anchor" href="#类加载器-class-loader" aria-label="Permalink to &quot;类加载器(Class Loader)&quot;">​</a></h2><p>类加载器负责将类文件加载到JVM中，不同的类加载器用于加载不同来源的类。JVM提供了几种主要的类加载器：</p><ol><li><strong>启动类加载器(Bootstrap Class Loader 即根加载器) :</strong><ul><li>加载JVM核心类库，如 <code>rt.jar</code>、<code>charsets.jar</code>等。</li><li>由C++实现，是JVM的一部分。</li></ul></li><li><strong>扩展类加载器(Extension Class Loader):</strong><ul><li>加载扩展类库，如 <code>lib/ext</code> 目录下的类。</li><li>由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现。</li></ul></li><li><strong>应用程序类加载器(Application Class Loader):</strong><ul><li>加载应用程序的类路径下的类，如 <code>classpath</code> 目录下的类。</li><li>由 <code>sum.misc.Launcher$AppClassLoader</code> 实现。</li></ul></li></ol><h2 id="类加载过程" tabindex="-1">类加载过程 <a class="header-anchor" href="#类加载过程" aria-label="Permalink to &quot;类加载过程&quot;">​</a></h2><p>JVM 类加载过程是将 Java 类文件加载到内存中，并准备好执行的过程。它包括加载、连接和初始化三个主要阶段。</p><h3 id="_1-加载-loading" tabindex="-1">1.加载(Loading) <a class="header-anchor" href="#_1-加载-loading" aria-label="Permalink to &quot;1.加载(Loading)&quot;">​</a></h3><p>在加载阶段，JVM 通过类加载器将类的二进制数据读取到内存中，并生成一个代表该类的 <code>Class</code> 对象。加载阶段主要包括以下步骤：</p><ol><li><strong>查找并加载类的二进制数据：</strong><ul><li>通过类加载器找到类文件并将其读取到内存中。</li><li>类文件可以来自多种来源，如文件系统、Jar包、网络等。</li></ul></li><li><strong>解析类的二进制数据：</strong><ul><li>将二进制数据解析为内存中的结构，生成 <code>Class</code> 对象。</li></ul></li><li><strong>创建 <code>Class</code> 对象：</strong><ul><li>在方法区创建一个 <code>Class</code> 对象，用于表示加载的类。</li></ul></li></ol><h3 id="_2-连接-linking" tabindex="-1">2.连接(Linking) <a class="header-anchor" href="#_2-连接-linking" aria-label="Permalink to &quot;2.连接(Linking)&quot;">​</a></h3><p>连接阶段将加载的类二进制数据合并到JVM运行时环境中，确保类的正确性和可用性。连接分为三个子阶段：验证、准备和解析。</p><ol><li><strong>验证(Verification):</strong> 验证阶段确保类文件的字节码符合JVM规范，不会破坏JVM安全性。主要包括以下几种验证： <ul><li><strong>文件格式验证:</strong> 检查类文件的魔数、版本号等基本格式。</li><li><strong>元数据验证:</strong> 检查类的元数据，如类的继承关系、实现的接口等。</li><li><strong>字节码验证:</strong> 检查字节码合法性，如类型检查、流量分析等。</li><li><strong>符号引用验证:</strong> 检查符号引用的合法性和可访问性。</li></ul></li><li><strong>准备(Preparation):</strong> 准备阶段为类的静态变量分配内存，并将其初始化为默认值。此时只分配内存，不执行任何初始化代码。 <ul><li><strong>分配内存:</strong> 为类的静态变量分配内存空间</li><li><strong>初始化默认值:</strong> 将静态变量初始化为默认值(如 <code>0</code> 、<code>null</code> 等)</li></ul></li><li><strong>解析(Resolution):</strong> 解析阶段将常量池中的符号引用(Symbolic Reference) 替换为直接引用(Direct Reference)。这一步是在需要的时候进行的，可能是在连接阶段，也可能是在运行时。</li></ol><h3 id="_3-初始化-initialization" tabindex="-1">3.初始化(Initialization) <a class="header-anchor" href="#_3-初始化-initialization" aria-label="Permalink to &quot;3.初始化(Initialization)&quot;">​</a></h3><p>初始化阶段是类加载过程的最后一步。该阶段执行类构造器 <code>&lt;clinit&gt;()</code> 方法，初始化静态变量和静态代码块中的内容。类构造器方法由编译器生成，包含类中的所有静态变量赋值语句和静态代码块。</p><ul><li><strong>静态变量初始化:</strong> 将静态变量初始化为指定的值。</li><li><strong>静态代码块执行:</strong> 执行类中的静态代码块。</li></ul><h2 id="类加载过程示例" tabindex="-1">类加载过程示例 <a class="header-anchor" href="#类加载过程示例" aria-label="Permalink to &quot;类加载过程示例&quot;">​</a></h2><p>假设有一个简单的Java类：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Static Block&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Constructor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>当加载这个类时，JVM会按照以下步骤进行：</p><ol><li><strong>加载阶段:</strong><ul><li>类加载器读取 <code>MyClass.class</code> 文件。</li><li>生成 <code>Class</code> 对象。</li></ul></li><li><strong>连接阶段:</strong><ul><li><strong>验证:</strong> 检查类文件格式、字节码等。</li><li><strong>准备:</strong> 分配静态变量 <code>value</code> 的内存并初始化为默认值 <code>0</code>。</li><li><strong>解析:</strong> 将符号引用解析为直接引用。</li></ul></li><li><strong>初始化阶段:</strong><ul><li>执行静态代码块，打印 <code>Static Block</code>。</li><li>将静态变量 <code>value</code> 初始化为 <code>123</code></li></ul></li></ol><h2 id="双亲委派机制" tabindex="-1">双亲委派机制 <a class="header-anchor" href="#双亲委派机制" aria-label="Permalink to &quot;双亲委派机制&quot;">​</a></h2><p>双亲委派机制(Parent Delegation Model)是 Java 中类加载器的一种工作机制，用于保证 Java 类加载工程中的安全性和一致性，该机制规定，当一个类加载器需要加载一个类时，首先将请求委派给他的父类加载器去完成，只有当父类加载器无法完成这个请求时，之类加载器才会尝试自己加载该类。</p><h3 id="委派的过程" tabindex="-1">委派的过程 <a class="header-anchor" href="#委派的过程" aria-label="Permalink to &quot;委派的过程&quot;">​</a></h3><p>假设有一个类 <code>MyClass</code> ，其类加载过程如下:</p><ol><li>应用程序类加载器接受到加载 <code>MyClass</code> 的请求。</li><li>应用程序类加载器将请求委派给他的父类加载器，即扩展类加载器。</li><li>扩展类加载器收到请求后，将其委派给启动类加载器。</li><li>启动类加载器尝试加载 <code>MyClass</code> 。如果成功，返回类对象；否则返回失败。</li><li>如果启动类加载器无法加载该类，则扩展类加载器尝试加载。如果成功，返回类对象；否则返回失败。</li><li>如果扩展类启动器也无法加载该类，则应用程序加载器尝试加载。如果成功，返回类对象；否则抛出 <code>ClassNotFoundException</code> 异常</li></ol><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li><strong>安全性:</strong> 通过双亲委派机制，可以确保核心类库(如 <code>java.lang.Object</code>)不会被自定义类加载器加载或替换，防止核心类库被篡改。</li><li><strong>避免重复加载:</strong> 同一个类在整个加载过程中只会被加载一次。</li><li><strong>类的唯一性:</strong> 确保由Bootstrap Class Loader 加载的类在个各类加载器环境中都是唯一的，从而保证了Java类型体系的一致性。</li></ul>`,27);function m(a,f,D,b,B,v){const t=o,n=d("ClientOnly");return e(),h("div",null,[y,c(n,null,{default:p(()=>{var i,s;return[(((i=a.$frontmatter)==null?void 0:i.aside)??!0)&&(((s=a.$frontmatter)==null?void 0:s.showArticleMetadata)??!0)?(e(),u(t,{key:0,article:a.$frontmatter},null,8,["article"])):C("",!0)]}),_:1}),A])}const V=r(_,[["render",m]]);export{q as __pageData,V as default};
