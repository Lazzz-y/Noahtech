import{_ as k}from"./chunks/ArticleMetadata.BqQPtrzx.js";import{_ as e,m as p,a as r,u as d,B as g,e as n,x as A,ah as o,o as l,p as y,q as c}from"./chunks/framework.Bi-mNMmX.js";import"./chunks/theme.NLG9-6OP.js";const x=JSON.parse('{"title":"Redis并发问题","description":"","frontmatter":{"title":"Redis并发问题","author":"Noah","date":"2024/07/10 16:44","categories":["Redis进阶"],"tags":["Redis","Redis进阶","并发"]},"headers":[],"relativePath":"courses/数据库/04-Redis进阶/07-Redis并发问题.md","filePath":"courses/数据库/04-Redis进阶/07-Redis并发问题.md","lastUpdated":1720612269000}'),D={name:"courses/数据库/04-Redis进阶/07-Redis并发问题.md"},C=n("h1",{id:"redis并发问题",tabindex:"-1"},[A("Redis并发问题 "),n("a",{class:"header-anchor",href:"#redis并发问题","aria-label":'Permalink to "Redis并发问题"'},"​")],-1),B=o(`<nav class="table-of-contents"><ul><li><a href="#缓存穿透">缓存穿透</a><ul><li><a href="#概念">概念</a></li><li><a href="#解决方法">解决方法</a></li></ul></li><li><a href="#缓存击穿">缓存击穿</a><ul><li><a href="#概念-1">概念</a></li><li><a href="#解决方法-1">解决方法</a></li></ul></li><li><a href="#缓存雪崩">缓存雪崩</a><ul><li><a href="#概念-2">概念</a></li><li><a href="#解决方法-2">解决方法</a></li></ul></li></ul></nav><div class="tip custom-block"><p class="custom-block-title">前言🔭</p><p>在项目开发中，数据都是要持久化到磁盘中去的，但是由于流量会越来越大，导致查询速度也逐渐变慢。所以在实战项目中，一般都会使用缓存来提升查询速度。Redis作为一款高性能的内存数据库，一般都会被用作缓存来使用。但是，Redis在并发情况下，可能会出现一些问题，比如缓存穿透、缓存雪崩、缓存击穿等。本节将介绍Redis并发问题以及解决方案。😄</p><ol><li>缓存雪崩 Cache Avalanche</li><li>缓存穿透 Cache Penetration</li><li>缓存击穿 Hotspot Invalid</li></ol></div><h2 id="缓存穿透" tabindex="-1">缓存穿透 <a class="header-anchor" href="#缓存穿透" aria-label="Permalink to &quot;缓存穿透&quot;">​</a></h2><img src="https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240710174847.jpg" style="zoom:80%;"><h3 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h3><p>缓存穿透是指用户访问一个数据，但是这个数据在缓存层并不存在，也就是缓存没有命中。于是直接向持久层数据库进行查询，发生持久层数据库也没有该数据，于是本次查询失败。当用户流量大的时候，缓存都没有命中，于是都去向持久层数据库发送请求，这会给持久层数据库造成很大的压力，这个时候就相当于出现了缓存穿透。</p><h3 id="解决方法" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法" aria-label="Permalink to &quot;解决方法&quot;">​</a></h3><h4 id="缓存空值" tabindex="-1">缓存空值 <a class="header-anchor" href="#缓存空值" aria-label="Permalink to &quot;缓存空值&quot;">​</a></h4><ul><li><strong>原理:</strong> 当查询到数据库中不存在的数据时，将空值(如 <code>null</code> 或特定标识) 缓存起来，设置一个合理的过期时间，这样下次相同的查询就可以直接从缓存层中返回，不要在访问数据库。</li></ul><p>简单示例:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> CachePenetrationDemo01</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Jedis</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Jedis</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;192.168.128.129&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">6001</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        CachePenetrationDemo01</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> CachePenetrationDemo01</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(cp.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getData</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getData</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(key) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">            // 查询数据库</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> getDataFromDB</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(key);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">            // 如果数据库不存在，则缓存数据不存在，设置一分钟过期时间</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setex</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(key, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">60</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;数据不存在&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">                // 如果数据库存在则缓存到缓存层</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setex</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(key, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">60</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, data.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(key);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDataFromDB</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">        // 模拟数据库查询结果为空</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h4 id="布隆过滤器" tabindex="-1">布隆过滤器 <a class="header-anchor" href="#布隆过滤器" aria-label="Permalink to &quot;布隆过滤器&quot;">​</a></h4><ul><li><strong>原理:</strong> 布隆过滤器是一种非常高效的数据结构，对所有可能查询的参数以 hash 形式存储。可以用来判断一个元素是否在一个集合中。虽然存在一个概率的误判，但对于缓存穿透问题，它可以有效过滤掉不存在的数据请求，避免这些请求直接到达数据库，给数据库造成压力。</li></ul><div class="info custom-block"><p class="custom-block-title">提醒🔭</p><p>在实际应用中，可以在缓存层先使用布隆过滤器检查数据是否存在，如果返回 <code>false</code> ，说明数据一定不存在，无需查询数据库；如果返回 <code>true</code> ，就需要进一步查询缓存或数据库确认数据的存在。</p></div><h2 id="缓存击穿" tabindex="-1">缓存击穿 <a class="header-anchor" href="#缓存击穿" aria-label="Permalink to &quot;缓存击穿&quot;">​</a></h2><img src="https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240710190431.jpg" style="zoom:80%;"><h3 id="概念-1" tabindex="-1">概念 <a class="header-anchor" href="#概念-1" aria-label="Permalink to &quot;概念&quot;">​</a></h3><p>缓存击穿是指一个热点key，在不停的扛着大并发，大并发集中对这一个key进行访问，当这个key失效的瞬间，持续的大并发就穿破缓存层直接访问持久层数据库，瞬间给持久层数据库带来巨大的压力。</p><h3 id="解决方法-1" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法-1" aria-label="Permalink to &quot;解决方法&quot;">​</a></h3><h4 id="互斥锁-mutex-lock" tabindex="-1">互斥锁(Mutex Lock) <a class="header-anchor" href="#互斥锁-mutex-lock" aria-label="Permalink to &quot;互斥锁(Mutex Lock)&quot;">​</a></h4><ul><li><strong>原理:</strong> 保证同一时间只有一个请求去访问数据库获取并更新缓存，其他请求需要等待锁释放后从缓存中读取数据。</li></ul><p>简单示例：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> HotspotInvalid</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Jedis</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Jedis</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;192.168.128.129&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">6001</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> lock</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 这里使用本地锁，在分布式环境下需要使用分布式锁</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getData</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(key);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            try</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">                // 再次检查数据，因为在上锁期间可能已经有其他线程更新了缓存</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(key);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                    data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> fetchFromDatabase</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(key);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                    cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(key, data); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 将数据写入缓存</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">fetchFromDatabase</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">        // 模拟从数据库获取数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Fetching data from database for key: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;Data for key: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span></code></pre></div><h4 id="永久缓存热点数据" tabindex="-1">永久缓存热点数据 <a class="header-anchor" href="#永久缓存热点数据" aria-label="Permalink to &quot;永久缓存热点数据&quot;">​</a></h4><ul><li><strong>原理:</strong> 将热点key永久保存在缓存中，这样只要数据不被删除或替换，就一直在缓存中，避免了过期问题。</li></ul><h2 id="缓存雪崩" tabindex="-1">缓存雪崩 <a class="header-anchor" href="#缓存雪崩" aria-label="Permalink to &quot;缓存雪崩&quot;">​</a></h2><img src="https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240710190457.jpg" style="zoom:80%;"><h3 id="概念-2" tabindex="-1">概念 <a class="header-anchor" href="#概念-2" aria-label="Permalink to &quot;概念&quot;">​</a></h3><p>缓存雪崩是指在某一个时间段，缓存集中失效，导致了大量的请求涌入持久层数据库中，给数据库带来巨大的压力。例如当用户请求一个过期的数据，如果没有适当的处理机制，那么这个请求会直接访问到持久层数据中。如果这种请求频繁发生，特别是在高并发的情况下，数据库将面临巨大的压力，可能会导致服务向变慢，甚至服务终端。</p><h3 id="解决方法-2" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法-2" aria-label="Permalink to &quot;解决方法&quot;">​</a></h3><h4 id="缓存失效" tabindex="-1">缓存失效 <a class="header-anchor" href="#缓存失效" aria-label="Permalink to &quot;缓存失效&quot;">​</a></h4><h5 id="过期时间随机化" tabindex="-1">过期时间随机化 <a class="header-anchor" href="#过期时间随机化" aria-label="Permalink to &quot;过期时间随机化&quot;">​</a></h5><ul><li><strong>原理:</strong> 通过为每个缓存项设置一个随机的过期时间，避免大量缓存同时过期，减少数据库的瞬时压力。</li></ul><h5 id="多级缓存" tabindex="-1">多级缓存 <a class="header-anchor" href="#多级缓存" aria-label="Permalink to &quot;多级缓存&quot;">​</a></h5><ul><li><strong>原理:</strong> 构建多级缓存，如本地缓存+远程缓存，利用本地缓存的高速度和远程缓存的大容量，分担请求压力，提高系统的稳定性和可用性。</li></ul><h5 id="缓存预热" tabindex="-1">缓存预热 <a class="header-anchor" href="#缓存预热" aria-label="Permalink to &quot;缓存预热&quot;">​</a></h5><ul><li><strong>原理:</strong> 缓存预热是指在系统启动或在预期的高峰访问时段之前，提前将热点数据加载到缓存中，以减少数据库访问的压力。这样可以避免在系统启动初期或负载高峰期，因缓存为准备好而导致数据库的压力激增。</li></ul><h4 id="缓存中间件故障" tabindex="-1">缓存中间件故障 <a class="header-anchor" href="#缓存中间件故障" aria-label="Permalink to &quot;缓存中间件故障&quot;">​</a></h4><h5 id="服务熔断" tabindex="-1">服务熔断 <a class="header-anchor" href="#服务熔断" aria-label="Permalink to &quot;服务熔断&quot;">​</a></h5><ul><li><strong>原理:</strong> 当检测到缓存中间件故障时，暂停业务逻辑，直接返回错误或默认值，避免系统整体崩溃。</li></ul>`,40);function F(s,u,E,m,b,f){const h=k,t=p("ClientOnly");return l(),r("div",null,[C,d(t,null,{default:g(()=>{var i,a;return[(((i=s.$frontmatter)==null?void 0:i.aside)??!0)&&(((a=s.$frontmatter)==null?void 0:a.showArticleMetadata)??!0)?(l(),y(h,{key:0,article:s.$frontmatter},null,8,["article"])):c("",!0)]}),_:1}),B])}const P=e(D,[["render",F]]);export{x as __pageData,P as default};
