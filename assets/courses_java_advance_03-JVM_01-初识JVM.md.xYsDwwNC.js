import{_ as n}from"./chunks/ArticleMetadata.BqQPtrzx.js";import{_ as s,m as c,a as J,u as v,B as m,e as l,x as d,ah as u,o as i,p as h,q as _}from"./chunks/framework.Bi-mNMmX.js";import"./chunks/theme.NLG9-6OP.js";const P=JSON.parse('{"title":"初识JVM","description":"","frontmatter":{"title":"初识JVM","author":"Noah","date":"2024/07/03 14:11","categories":["JVM"],"tags":["Java","JVM","JDK"]},"headers":[],"relativePath":"courses/java/advance/03-JVM/01-初识JVM.md","filePath":"courses/java/advance/03-JVM/01-初识JVM.md","lastUpdated":1720010212000}'),g={name:"courses/java/advance/03-JVM/01-初识JVM.md"},p=l("h1",{id:"初识jvm",tabindex:"-1"},[d("初识JVM "),l("a",{class:"header-anchor",href:"#初识jvm","aria-label":'Permalink to "初识JVM"'},"​")],-1),V=u('<nav class="table-of-contents"><ul><li><a href="#jvm概述">JVM概述</a></li><li><a href="#jvm体系架构">JVM体系架构</a></li><li><a href="#native关键字">native关键字</a></li></ul></nav><div class="tip custom-block"><p class="custom-block-title">面试常见问题：</p><ol><li>请谈谈你对JVM的理解？</li><li>Java8虚拟机和之前的变化更新？</li><li>什么是OOM，什么是溢出StackOverFlowError？怎么分析？</li><li>JVM常用的调优参数有哪些？</li><li>内存快照如何抓取，怎么分析Dump文件？</li><li>谈谈JVM中，你对类加载器的认识？</li></ol></div><h2 id="jvm概述" tabindex="-1">JVM概述 <a class="header-anchor" href="#jvm概述" aria-label="Permalink to &quot;JVM概述&quot;">​</a></h2><p>JVM（Java Virtual Machine，Java虚拟机）是一个虚拟化的计算环境，负责执行Java字节码并提供运行Java程序所需的系统资源，它是Java平台的一部分，能够使Java程序具有跨平台的特性，实现“一次编写，到处运行”。</p><h2 id="jvm体系架构" tabindex="-1">JVM体系架构 <a class="header-anchor" href="#jvm体系架构" aria-label="Permalink to &quot;JVM体系架构&quot;">​</a></h2><p>JVM主要有由以下几个部分组成：</p><ol><li><strong>类加载器子系统（Class Loader Subsystem）：</strong><ul><li>负责加载、链接和初始化Java类。把字节码文件(.class)加载到JVM中。</li><li>包括加载、验证、准备、解析和初始化五个阶段</li></ul></li><li><strong>运行时数据区（Runtime Data Areas）：</strong> JVM在运行时使用的内存结构，包括以下几个重要区域： <ul><li><strong>方法区（Method Area）：</strong> 存储已加载的类信息（构造方法、接口定义），常量、静态变量和运行时常量池等。</li><li><strong>堆（Heap）：</strong> 存储所有对象实例，是垃圾收集的主要区域。</li><li><strong>栈（Java Stack）：</strong> 每个线程都会创建一个Java栈，存储局部变量，操作数栈，方法出口等信息。每个方法在调用时都会创建一个栈帧。</li><li><strong>程序计数器（Program Counter Register）：</strong> 每个线程都有一个独立的程序计数器，存储当前线程正在执行的字节码的地址。</li><li><strong>本地方法栈（Native Method Stack）：</strong> 为JVM使用本地方法服务，存储本地方法和调用结果。</li></ul></li><li><strong>执行引擎（Exection Engine）：</strong><ul><li><strong>解释器（Interpreter）：</strong> 将字节码解释称机器码逐条执行，但效率较低。</li><li><strong>即时编译器（JIT Compiler）：</strong> 将热点代码编译成机器码，提高执行效率。</li><li><strong>垃圾收集器（Garbage Collector）：</strong> 自动管理堆内存，回收不在使用的对象，避免内存溢出。</li></ul></li><li><strong>本地方法接口（JNI，Java Native Interface）：</strong><ul><li>允许Java代码调用和被本地方法调用，通常是C或者C++编写的程序，用于与操作系统的底层资源进行交互。</li></ul></li></ol><img src="https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240703145327.png" style="zoom:80%;"><p>Java栈、本地方法栈、程序计数器不会有垃圾回收，否则程序会死掉。百分之99的JVM调优都是在方法区和堆（99%是堆）中调优，Java栈、本地方法栈、程序计数器不会有垃圾的存在。</p><h2 id="native关键字" tabindex="-1">native关键字 <a class="header-anchor" href="#native关键字" aria-label="Permalink to &quot;native关键字&quot;">​</a></h2><ul><li>凡是带了native关键字的，说明Java本身的作用范围达不到要求了，会去调用底层C语言的库。</li><li>调用本地方法接口 JNI(Java Native Interface)</li><li>JNI 的作用: 开拓Java的使用，融合不同的编程语言为Java所用。</li><li>Java诞生之初C、C++横行，Java想要立足，就必须要有调用C、C++的程序。</li><li>它在内存空间中专门开辟了一块标记区域：Native Method Stack，等级native方法。</li><li>在最终执行的时候，加载本地方法库中的方法通过JNI。</li></ul><p>目前该关键字使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机。</p>',12);function M(a,f,C,N,b,k){const o=n,r=c("ClientOnly");return i(),J("div",null,[p,v(r,null,{default:m(()=>{var t,e;return[(((t=a.$frontmatter)==null?void 0:t.aside)??!0)&&(((e=a.$frontmatter)==null?void 0:e.showArticleMetadata)??!0)?(i(),h(o,{key:0,article:a.$frontmatter},null,8,["article"])):_("",!0)]}),_:1}),V])}const x=s(g,[["render",M]]);export{P as __pageData,x as default};
