import{_ as h}from"./chunks/ArticleMetadata.BuBbIslv.js";import{_ as p,m as k,a as r,u as o,B as d,e as n,x as c,ah as g,o as t,p as A,q as y}from"./chunks/framework.Bi-mNMmX.js";import"./chunks/theme.ulrGMYOD.js";const q=JSON.parse('{"title":"方法区","description":"","frontmatter":{"title":"方法区","author":"Noah","date":"2024/07/03 18:03","categories":["JVM"],"tags":["Java","JVM","JDK"]},"headers":[],"relativePath":"courses/java/advance/03-JVM/04-方法区.md","filePath":"courses/java/advance/03-JVM/04-方法区.md","lastUpdated":1720612269000}'),D={name:"courses/java/advance/03-JVM/04-方法区.md"},C=n("h1",{id:"方法区",tabindex:"-1"},[c("方法区 "),n("a",{class:"header-anchor",href:"#方法区","aria-label":'Permalink to "方法区"'},"​")],-1),u=g(`<nav class="table-of-contents"><ul><li><a href="#主要内容">主要内容</a></li><li><a href="#特点">特点</a></li><li><a href="#元空间">元空间</a></li><li><a href="#优点">优点</a></li><li><a href="#示例">示例</a></li></ul></nav><p>方法区(Method Area) 是JVM内存模型中一个重要的内存区域，他用于存储已加载的类信息、常量、静态变量、即时编译器编译后的代码(即JIT编译后的代码)等数据。方法区是所有线程共享的内存区域。</p><h2 id="主要内容" tabindex="-1">主要内容 <a class="header-anchor" href="#主要内容" aria-label="Permalink to &quot;主要内容&quot;">​</a></h2><ol><li><strong>类信息:</strong> 每个被加载的类或者接口的元数据，包括类的名称、父类信息、接口信息、方法和字段的信息等。</li><li><strong>常量池:</strong> 包括类中的常量，如字符串常量、数值常量和方法引用、字段引用等。</li><li><strong>静态变量:</strong> 类的静态字段。</li><li><strong>即时编译器编译后的代码:</strong> JIT编译器将一些热点代码编译为本地机器码，存储在方法区中。</li><li><strong>运行时常量池(Runtime Constant Pool):</strong> 存储编译期生成的各种字面量和符号引用。</li></ol><h2 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h2><ol><li><strong>线程共享:</strong> 方法区在JVM中是所有线程共享的内存区域。</li><li><strong>垃圾回收:</strong> 方法区的垃圾回收频率较低，但这并不意味着它不进行垃圾回收。方法区的垃圾回收主要针对常量池和对类型的卸载。</li></ol><h2 id="元空间" tabindex="-1">元空间 <a class="header-anchor" href="#元空间" aria-label="Permalink to &quot;元空间&quot;">​</a></h2><p>在Java 8以后的版本中，方法区的实现由永久代变为元空间。元空间在本质上依然是方法区，只是存储的位置从JVM中移到了本地内存中。</p><h2 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h2><ol><li><strong>减少内存溢出:</strong> 永久代大小是固定的，容易导致内存溢出。元空间的大小由系统内存限制，减少了内存溢出的可能性。</li><li><strong>更灵活的内存管理:</strong> 元空间可以根据需要动态扩展和收缩。</li></ol><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> MethodAreaExample</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(MyClass.staticField);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> staticField</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Static block executed&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> method</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Instance method executed&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><ol><li><strong>类加载:</strong> 当 <code>MethodAreaExample</code> 类和 <code>MyClass</code> 类被加载时，其类信息、静态变量和常量池等息被存储在方法区中。</li><li><strong>静态变量初始化:</strong> 静态变量 <code>staticField</code>被初始化在方法区中。</li><li><strong>静态代码块执行:</strong> 静态代码块在类加载时执行，输出 <code>Static block executed</code> 。</li></ol>`,13);function B(s,F,m,_,E,f){const l=h,e=k("ClientOnly");return t(),r("div",null,[C,o(e,null,{default:d(()=>{var a,i;return[(((a=s.$frontmatter)==null?void 0:a.aside)??!0)&&(((i=s.$frontmatter)==null?void 0:i.showArticleMetadata)??!0)?(t(),A(l,{key:0,article:s.$frontmatter},null,8,["article"])):y("",!0)]}),_:1}),u])}const x=p(D,[["render",B]]);export{q as __pageData,x as default};
