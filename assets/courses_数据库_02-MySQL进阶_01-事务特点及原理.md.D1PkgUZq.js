import{_ as n}from"./chunks/ArticleMetadata.BqQPtrzx.js";import{_ as r,m as c,a as d,u as p,B as h,e as l,x as u,ah as m,o as i,p as b,q as f}from"./chunks/framework.Bi-mNMmX.js";import"./chunks/theme.NLG9-6OP.js";const S=JSON.parse('{"title":"事务特点及原理","description":"","frontmatter":{"title":"事务特点及原理","author":"Noah","date":"2024/06/28 20:22","categories":["MySQL进阶"],"tags":["MySQL","MySQL进阶","事务","并发事务"]},"headers":[],"relativePath":"courses/数据库/02-MySQL进阶/01-事务特点及原理.md","filePath":"courses/数据库/02-MySQL进阶/01-事务特点及原理.md","lastUpdated":1720612269000}'),_={name:"courses/数据库/02-MySQL进阶/01-事务特点及原理.md"},y=l("h1",{id:"事务特点及原理",tabindex:"-1"},[u("事务特点及原理 "),l("a",{class:"header-anchor",href:"#事务特点及原理","aria-label":'Permalink to "事务特点及原理"'},"​")],-1),A=m(`<nav class="table-of-contents"><ul><li><a href="#什么是事务">什么是事务？</a></li><li><a href="#事务的四个特性-acid">事务的四个特性(ACID)</a><ul><li><a href="#原子性-atomicity">原子性 (Atomicity)</a></li><li><a href="#一致性-consistency">一致性(Consistency)</a></li><li><a href="#隔离性">隔离性</a></li><li><a href="#持久性">持久性</a></li></ul></li><li><a href="#隔离级别">隔离级别</a></li><li><a href="#并发事务产生的问题">并发事务产生的问题</a><ul><li><a href="#更新丢失">更新丢失</a></li><li><a href="#脏读">脏读</a></li><li><a href="#不可重复读">不可重复读</a></li><li><a href="#幻读">幻读</a></li></ul></li></ul></nav><div class="tip custom-block"><p class="custom-block-title">前言</p><p>本章涉及到的 <code>MySQL</code> 日志系统会在后续单独开一篇文章介绍。</p></div><h2 id="什么是事务" tabindex="-1">什么是事务？ <a class="header-anchor" href="#什么是事务" aria-label="Permalink to &quot;什么是事务？&quot;">​</a></h2><p>数据库中的事务是指对数据库执行一系列操作，在同一个事务中，这些操作最终要么全部执行成功，要么全部执行失败，不存在部分成功的情况。</p><div class="info custom-block"><p class="custom-block-title">举个栗子:</p><p>张飞需要给刘备转账1000元，过程如下：</p><ul><li>从张飞账户上扣款1000</li><li>给刘备账户上增加1000</li></ul><p>如果在事务的支持下，上面最终只会有两种结果</p><ul><li>操作成功，张飞账户上减少1000，刘备账户上增加1000。</li><li>操作失败，刘备张飞双方账户没有变化。</li></ul></div><h2 id="事务的四个特性-acid" tabindex="-1">事务的四个特性(ACID) <a class="header-anchor" href="#事务的四个特性-acid" aria-label="Permalink to &quot;事务的四个特性(ACID)&quot;">​</a></h2><h3 id="原子性-atomicity" tabindex="-1">原子性 (Atomicity) <a class="header-anchor" href="#原子性-atomicity" aria-label="Permalink to &quot;原子性 (Atomicity)&quot;">​</a></h3><p>事务的整个过程如原子操作一样，要么全部成功，要么全部失败。</p><p>实现原理：<code>undo log</code></p><h3 id="一致性-consistency" tabindex="-1">一致性(Consistency) <a class="header-anchor" href="#一致性-consistency" aria-label="Permalink to &quot;一致性(Consistency)&quot;">​</a></h3><p>一个事务必须让数据库从一个一致性的状态变换到另一个一致性的状态。例如张飞像刘备转账，张飞的账户的钱少了，而刘备账户的钱却没有增加，那么我们认为此时的数据处于不一致的状态。</p><p>实现原理：一致性是我们的根本追求，依托于其他三个特性</p><h3 id="隔离性" tabindex="-1">隔离性 <a class="header-anchor" href="#隔离性" aria-label="Permalink to &quot;隔离性&quot;">​</a></h3><p>一个事务的执行，不能被其他事务干扰。一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。</p><p>实现原理：多版本井发控制，即 <code>MVCC</code> ，和锁</p><h3 id="持久性" tabindex="-1">持久性 <a class="header-anchor" href="#持久性" aria-label="Permalink to &quot;持久性&quot;">​</a></h3><p>事务一旦提交，对数据库中的数据改变是永久性的。当事务提交之后，数据会持久化存储在硬盘，就算是断电或者其他原因也不能影响结果。</p><p>实现原理：<code>redo log</code></p><h2 id="隔离级别" tabindex="-1">隔离级别 <a class="header-anchor" href="#隔离级别" aria-label="Permalink to &quot;隔离级别&quot;">​</a></h2><ul><li><code>read uncommitted</code> ：读未提交，允许读未提交的数据，即脏读。</li><li><code>read committed</code> : 读已提交，只能读已提交的数据，防止脏读。</li><li><code>repeatable read</code> : 可重复读，确保在同一个事务中多次读取同样的数据结果是一样的，防止不可重复度(默认隔离级别)。</li><li><code>serializable</code> : 串行化，最高隔离级别，完全隔离，事务必须安顺序执行，防止幻读</li></ul><h2 id="并发事务产生的问题" tabindex="-1">并发事务产生的问题 <a class="header-anchor" href="#并发事务产生的问题" aria-label="Permalink to &quot;并发事务产生的问题&quot;">​</a></h2><h3 id="更新丢失" tabindex="-1">更新丢失 <a class="header-anchor" href="#更新丢失" aria-label="Permalink to &quot;更新丢失&quot;">​</a></h3><p>丢失更新是两个不同的事务(或 <code>Java</code> 程序线程) 在某一时刻对同一数据进行读取后，先后进行修改，导致第一次操作数据丢失。</p><div class="warning custom-block"><p class="custom-block-title"><strong>注意</strong>💡</p><p>第一类: A, B 事务同时操作同一数据，A 先对数据进行了更改，B 再次更改时失败然后回滚，把A更新的数据连带回滚。(事务撤销造成的撤销丢失)。</p><p>第二类：A，B 事务同时操作同一数据，A先对改数据进行了更改，B再次更改并且提交，把A提交的数据给覆盖了。(事务提交造成的覆盖丢失)。</p></div><h3 id="脏读" tabindex="-1">脏读 <a class="header-anchor" href="#脏读" aria-label="Permalink to &quot;脏读&quot;">​</a></h3><p>一个事务在执行的过程中读取到了其他事务还没有提交的数据。</p><div class="warning custom-block"><p class="custom-block-title"><strong>注意</strong>💡</p><p>A，B 两个事务并发且操作同一数据，A事务对数据进行了修改还没提交，B事务访问并使用了这条数据，此时A事务回滚，那么B事务读到的数据就是脏数据。B事务读到的数据还是回滚前的数据。</p></div><h3 id="不可重复读" tabindex="-1">不可重复读 <a class="header-anchor" href="#不可重复读" aria-label="Permalink to &quot;不可重复读&quot;">​</a></h3><p>同一事务中，多次读取同一数据返回的结果有所不同。换句话说，后续读取可以读到另一事务已经提交的<strong>更新数据</strong>。</p><h3 id="幻读" tabindex="-1">幻读 <a class="header-anchor" href="#幻读" aria-label="Permalink to &quot;幻读&quot;">​</a></h3><p>幻读是指一个事务中，多次读取同一个查询条件的数据集合时，由于其他事务插入或删除了数据，导致两次读取数据集合不一样。这种现象在并发环境下容易出现，特别是在隔离级别低的情况下。</p><div class="info custom-block"><p class="custom-block-title">举个栗子</p><p>假如现在有一个数据库 <code>employess</code> ，记录了所有员工的信息：</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE employess (</span></span>
<span class="line"><span>	id INT PRIMARY KEY,</span></span>
<span class="line"><span>	name VARCHAR(100),</span></span>
<span class="line"><span>    salary DECIMAL(10,2)</span></span>
<span class="line"><span>);</span></span></code></pre></div><p>假设当前表中的数据如下：</p><table tabindex="0"><thead><tr><th>id</th><th>name</th><th style="text-align:left;">salary</th></tr></thead><tbody><tr><td>1</td><td>张飞</td><td style="text-align:left;">5000</td></tr><tr><td>2</td><td>刘备</td><td style="text-align:left;">6000</td></tr></tbody></table><p>假设有两个事务，A 和 B</p><ul><li>事务 A ： <ol><li>开始事务</li><li>查询工资大于4000的员工</li><li>等待一段时间</li><li>再次查询工资大于4000的员工</li><li>提交事务</li></ol></li><li>事务 B : <ol><li>开始事务</li><li>插入一条工资为5500的员工信息，这里取名为关羽</li><li>提交事务</li></ol></li></ul><p>在事务A 的第一次查询中，结果是<strong>张飞</strong>,、<strong>刘备</strong>。在事务B插入了一条新纪录之后，事务A的第二次查询中，结果多了一条<strong>关羽</strong>的记录。这里事务A在查询时看到了事务B在期间插入的新数据，这就是幻读。</p></div>`,32);function k(a,g,q,v,x,C){const o=n,s=c("ClientOnly");return i(),d("div",null,[y,p(s,null,{default:h(()=>{var e,t;return[(((e=a.$frontmatter)==null?void 0:e.aside)??!0)&&(((t=a.$frontmatter)==null?void 0:t.showArticleMetadata)??!0)?(i(),b(o,{key:0,article:a.$frontmatter},null,8,["article"])):f("",!0)]}),_:1}),A])}const T=r(_,[["render",k]]);export{S as __pageData,T as default};
