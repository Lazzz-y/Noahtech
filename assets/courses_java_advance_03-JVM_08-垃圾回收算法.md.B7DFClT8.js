import{_ as i}from"./chunks/ArticleMetadata.CkeQ1Cwq.js";import{_ as s,m as p,a as c,u as g,B as m,e as r,x as u,ah as h,o,p as _,q as d}from"./chunks/framework.Bi-mNMmX.js";import"./chunks/theme.BaTNwBwr.js";const N=JSON.parse('{"title":"垃圾回收算法","description":"","frontmatter":{"title":"垃圾回收算法","author":"Noah","date":"2024/07/05 14:44","categories":["JVM"],"tags":["Java","JVM","JDK"]},"headers":[],"relativePath":"courses/java/advance/03-JVM/08-垃圾回收算法.md","filePath":"courses/java/advance/03-JVM/08-垃圾回收算法.md","lastUpdated":1720612269000}'),f={name:"courses/java/advance/03-JVM/08-垃圾回收算法.md"},k=r("h1",{id:"垃圾回收算法",tabindex:"-1"},[u("垃圾回收算法 "),r("a",{class:"header-anchor",href:"#垃圾回收算法","aria-label":'Permalink to "垃圾回收算法"'},"​")],-1),b=h('<nav class="table-of-contents"><ul><li><a href="#标记-清除算法-mark-sweep">标记-清除算法(Mark-Sweep)</a></li><li><a href="#标记-整理算法-mark-compact">标记-整理算法(Mark-Compact)</a></li><li><a href="#复制算法-copying">复制算法(Copying)</a></li><li><a href="#分代收集算法-generational-collection">分代收集算法(Generational Collection)</a></li></ul></nav><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>JVM 的垃圾回收 (GC) 机制是其内存管理的核心。通过垃圾回收，JVM能自动回收不在使用的对象，从而避免内存泄漏，确保应用程序高效运行。JVM使用多种垃圾回收算法，每种算法都有其特定的应用场景和优化目标。</p></div><h2 id="标记-清除算法-mark-sweep" tabindex="-1">标记-清除算法(Mark-Sweep) <a class="header-anchor" href="#标记-清除算法-mark-sweep" aria-label="Permalink to &quot;标记-清除算法(Mark-Sweep)&quot;">​</a></h2><p><strong>原理:</strong> 标记清除算法分为两个阶段：<strong>标记</strong>和<strong>清除</strong></p><ul><li><strong>标记阶段:</strong> 垃圾收集器从根节点开始遍历所有可达对象，并标记这些对象。</li><li><strong>清除阶段:</strong> 垃圾收集器遍历堆，将没有被标记的对象视为垃圾并回收它们所占用的内存。</li></ul><p><strong>优点:</strong></p><ul><li>简单实现。</li><li>无需移动对象，只需标记和清理。</li></ul><p><strong>缺点:</strong></p><ul><li>标记和清除阶段效率较低，尤其是当对象数量较多时。</li><li>清楚阶段后会产生大量的不连续的内存空间(内存碎片)，导致新对象分配变慢。</li></ul><p><strong>适用场景:</strong></p><ul><li>存活数量较多且清理对象较少的情况下比较高效。</li><li>适用于老年代。</li></ul><p><img src="https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240705152343.gif" alt=""></p><p>图片来源: <a href="ttps://mp.weixin.qq.com/s/DvPaMfn7xEKIilv-_Ojk8g" target="_blank" rel="noreferrer">码农参上</a></p><h2 id="标记-整理算法-mark-compact" tabindex="-1">标记-整理算法(Mark-Compact) <a class="header-anchor" href="#标记-整理算法-mark-compact" aria-label="Permalink to &quot;标记-整理算法(Mark-Compact)&quot;">​</a></h2><p>**原理: ** 标记整理算法在标记阶段与标记清除算法相同，在整理阶段，不仅清理垃圾对象，还会压缩所有存活的对象，移动它们至内存的一端，确保空间的连续性。</p><ul><li><strong>标记阶段:</strong> 与标记清除算法相同，标记所有可达对象。</li><li><strong>整理阶段:</strong> 将存活对象压缩到堆的一端，清理掉未标记的对象并释放其内存。</li></ul><p><strong>优点:</strong></p><ul><li>避免了内存碎片的问题，使得内存分配更加高效。</li></ul><p><strong>缺点:</strong></p><ul><li>移动对象和压缩操作比较耗时，尤其是当存活对象较多时。</li></ul><p><strong>适用场景:</strong></p><ul><li>存活数量较多且清理对象较少的情况下比较高效。</li><li>适用于老年代。</li></ul><p><img src="https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240705152925.gif" alt=""></p><p>图片来源: <a href="ttps://mp.weixin.qq.com/s/DvPaMfn7xEKIilv-_Ojk8g" target="_blank" rel="noreferrer">码农参上</a></p><h2 id="复制算法-copying" tabindex="-1">复制算法(Copying) <a class="header-anchor" href="#复制算法-copying" aria-label="Permalink to &quot;复制算法(Copying)&quot;">​</a></h2><p><strong>原理:</strong> 复制算法将堆内存划分为两个相同大小的区域: From 区 和 To 区，即两个Survivor区。它通过将对象从一个区复制到另外一个区来实现垃圾回收。</p><ul><li><strong>分配阶段:</strong> 对象分配在From区，即谁空谁是To</li><li><strong>复制阶段:</strong> 当From区满时，垃圾收集器遍历From区，复制存活对象到To区，并一次性清理掉From区</li></ul><p><strong>优点:</strong></p><ul><li>复制和清理操作高效，分配与复制效率较高。</li><li>避免了内存碎片问题。</li></ul><p><strong>缺点:</strong></p><ul><li>永远有一半的内存空间处于空的状态，浪费了一半的内存空间。</li></ul><p><img src="https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240705152955.gif" alt=""></p><p>图片来源: <a href="ttps://mp.weixin.qq.com/s/DvPaMfn7xEKIilv-_Ojk8g" target="_blank" rel="noreferrer">码农参上</a></p><h2 id="分代收集算法-generational-collection" tabindex="-1">分代收集算法(Generational Collection) <a class="header-anchor" href="#分代收集算法-generational-collection" aria-label="Permalink to &quot;分代收集算法(Generational Collection)&quot;">​</a></h2><p><strong>原理:</strong> 分代收集算法是根据堆的区域划分，一般是把堆内存分为新生代和老年代，再根据区域的特点选择最佳的垃圾回收算法。</p><ul><li><strong>新生代:</strong> 存储新创建的对象，使用复制算法进行垃圾回收，因为大多数新对象会很快成为垃圾。</li><li><strong>老年代:</strong> 存储生命周期较长的对象，使用标记-清除或标记整理算法进行垃圾回收。</li></ul><p><strong>优点:</strong></p><ul><li>根据对象的生命周期优化回收效率。</li><li>新生代回收频繁且快速，老年代回收较少但耗时。</li></ul><p><strong>缺点:</strong></p><ul><li>需要综合考虑多种算法，JVM实现复杂。</li><li>老年代的回收效率相对较低。</li></ul><p><img src="https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240705152959.gif" alt=""></p><p>图片来源: <a href="ttps://mp.weixin.qq.com/s/DvPaMfn7xEKIilv-_Ojk8g" target="_blank" rel="noreferrer">码农参上</a></p>',42);function v(t,M,q,C,w,x){const l=i,n=p("ClientOnly");return o(),c("div",null,[k,g(n,null,{default:m(()=>{var a,e;return[(((a=t.$frontmatter)==null?void 0:a.aside)??!0)&&(((e=t.$frontmatter)==null?void 0:e.showArticleMetadata)??!0)?(o(),_(l,{key:0,article:t.$frontmatter},null,8,["article"])):d("",!0)]}),_:1}),b])}const T=s(f,[["render",v]]);export{N as __pageData,T as default};
