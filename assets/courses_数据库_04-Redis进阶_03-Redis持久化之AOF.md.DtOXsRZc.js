import{_ as o}from"./chunks/ArticleMetadata.BqQPtrzx.js";import{_ as r,m as h,a as d,u as p,B as c,e as s,x as u,ah as g,o as l,p as F,q as k}from"./chunks/framework.Bi-mNMmX.js";import"./chunks/theme.NLG9-6OP.js";const x=JSON.parse('{"title":"Redis持久化之AOF","description":"","frontmatter":{"title":"Redis持久化之AOF","author":"Noah","date":"2024/07/07 20:17","categories":["Redis进阶"],"tags":["Redis","Redis进阶"]},"headers":[],"relativePath":"courses/数据库/04-Redis进阶/03-Redis持久化之AOF.md","filePath":"courses/数据库/04-Redis进阶/03-Redis持久化之AOF.md","lastUpdated":1720612269000}'),A={name:"courses/数据库/04-Redis进阶/03-Redis持久化之AOF.md"},f=s("h1",{id:"redis持久化之aof",tabindex:"-1"},[u("Redis持久化之AOF "),s("a",{class:"header-anchor",href:"#redis持久化之aof","aria-label":'Permalink to "Redis持久化之AOF"'},"​")],-1),b=g(`<nav class="table-of-contents"><ul><li><a href="#aof-工作原理">AOF 工作原理</a><ul><li><a href="#主要步骤">主要步骤</a></li></ul></li><li><a href="#aof工作流程">AOF工作流程</a></li><li><a href="#配置-aof-持久化">配置 AOF 持久化</a><ul><li><a href="#配置文件">配置文件</a></li><li><a href="#文件同步策略">文件同步策略</a></li></ul></li><li><a href="#aof-重写-rewrite">AOF 重写(rewrite)</a><ul><li><a href="#自动触发重写">自动触发重写</a></li><li><a href="#手动触发重写">手动触发重写</a></li></ul></li><li><a href="#aof-的优缺点">AOF 的优缺点</a><ul><li><a href="#优点">优点</a></li><li><a href="#缺点">缺点</a></li></ul></li><li><a href="#rdb-和-aof-对比">RDB 和 AOF 对比</a></li></ul></nav><p>AOF（Append-Only File）是 Redis 提供的一种持久化机制，它通过记录每一个写操作来实现数据的持久化存储。与 RDB 快照相比，AOF提供了更高的数据恢复精度，因为它能够以更细粒度的方式记录数据变化。</p><h2 id="aof-工作原理" tabindex="-1">AOF 工作原理 <a class="header-anchor" href="#aof-工作原理" aria-label="Permalink to &quot;AOF 工作原理&quot;">​</a></h2><p>AOF 通过将每一个写操作(如 SET、SADD 等)追加到一个日志文件中来记录数据变更。当服务器重启时，Redis 会重新执行这些写操作以恢复数据。</p><h3 id="主要步骤" tabindex="-1">主要步骤 <a class="header-anchor" href="#主要步骤" aria-label="Permalink to &quot;主要步骤&quot;">​</a></h3><ol><li><strong>写操作追加:</strong><ul><li>每个写操作都会以 Redis 命令的形式被追加到 AOF 文件中 <code>appendonly.aof</code>。</li></ul></li><li><strong>文件同步:</strong><ul><li>根据配置，Redis 以不同的同步频率将 AOF 文件同步到磁盘上。</li></ul></li><li><strong>重写:</strong><ul><li>随着时间推移，AOF 文件会变得越来越大。为了防止 AOF 文件过大，Redis 会定期进行重写（rewrite），以生成更小和高效的 AOF 文件。</li></ul></li></ol><h2 id="aof工作流程" tabindex="-1">AOF工作流程 <a class="header-anchor" href="#aof工作流程" aria-label="Permalink to &quot;AOF工作流程&quot;">​</a></h2><ol><li>子进程fork父进程。</li><li>子进程根据内存中的数据快照，将写命令记录在临时的AOF文件中。父进程继续处理 Client 请求。</li><li>父进程将写命令几率在临时缓存里面，并写入原来的AOF文件中。</li><li>临时 AOF 文件记录完成数据快照中的命令后，子进程通知父进程写入完毕。</li><li>父进程将缓存的写命令写入到临时文件。</li><li>父进程用写入完毕的临时 AOF 文件替换旧的 AOF 文件。</li><li>父进程后面的写命令都将往新的AOF文件中追加。</li></ol><p><img src="https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240708134057.jpg" alt=""></p><h2 id="配置-aof-持久化" tabindex="-1">配置 AOF 持久化 <a class="header-anchor" href="#配置-aof-持久化" aria-label="Permalink to &quot;配置 AOF 持久化&quot;">​</a></h2><h3 id="配置文件" tabindex="-1">配置文件 <a class="header-anchor" href="#配置文件" aria-label="Permalink to &quot;配置文件&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># 启用AOF持久化</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">appendonly</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> yes</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># AOF文件名</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">appendfilename</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;appendonly.aof&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># AOF文件保存路径</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">dir</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /var/lib/redis</span></span></code></pre></div><h3 id="文件同步策略" tabindex="-1">文件同步策略 <a class="header-anchor" href="#文件同步策略" aria-label="Permalink to &quot;文件同步策略&quot;">​</a></h3><p>Redis 提供三种同步策略，分别是 <code>always</code>、<code>everysec</code>、<code>no</code>，这些策略会影响数据安全性和写性能。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># AOF文件的同步策略</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">appendfsync</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> everysec</span></span></code></pre></div><ul><li><strong><code>always</code>:</strong> 每次写操作都立即同步到磁盘，保证最大的数据安全性，但性能较低。</li><li><strong><code>everysec</code>:</strong> 每秒同步一次，写性能与数据安全性之间的良好折中，推荐配置。</li><li><strong><code>no</code>:</strong> 由操作系统决定何时同步，性能最好，但数据安全性最低。</li></ul><h2 id="aof-重写-rewrite" tabindex="-1">AOF 重写(rewrite) <a class="header-anchor" href="#aof-重写-rewrite" aria-label="Permalink to &quot;AOF 重写(rewrite)&quot;">​</a></h2><p>AOF 文件会随着写操作的增多而不对增长，Redis 提供AOF 重写机制来优化文件大小和性能。</p><h3 id="自动触发重写" tabindex="-1">自动触发重写 <a class="header-anchor" href="#自动触发重写" aria-label="Permalink to &quot;自动触发重写&quot;">​</a></h3><p>通过以下配置，Redis会在满足条件时自动触发 AOF 重写:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># AOF文件重写触发条件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">auto-aof-rewrite-percentage</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 100</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">auto-aof-rewrite-min-size</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> 64mb</span></span></code></pre></div><ul><li><strong><code>auto-aof-rewrite-percentage</code> :</strong> 设置当前 AOF 文件大小相对于上一次重写后的增长百分比，超过该百分比时触发重写。</li><li><strong><code>auto-aof-rewrite-min-size</code>:</strong> 设置重写的最小文件大小，当 AOF 文件大小小于此值时不进行重写。</li></ul><h3 id="手动触发重写" tabindex="-1">手动触发重写 <a class="header-anchor" href="#手动触发重写" aria-label="Permalink to &quot;手动触发重写&quot;">​</a></h3><p>可以通过 Redis 命令手动触发AOF重写</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> BGREWRITEAOF</span></span></code></pre></div><h2 id="aof-的优缺点" tabindex="-1">AOF 的优缺点 <a class="header-anchor" href="#aof-的优缺点" aria-label="Permalink to &quot;AOF 的优缺点&quot;">​</a></h2><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li><strong>数据恢复精度高:</strong> 相比于RDB，AOF 能够更细粒度的记录数据，每一个写操作都会被保存。</li><li><strong>数据丢失少:</strong> 默认配置下(appendfsync everysec)，最多只会丢失1秒的数据。</li><li><strong>可读性强:</strong> AOF 文件是一个包含所有写操作的日志，可以方便的进行审计和分析。</li></ul><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li><strong>文件较大:</strong> 由于每个写操作都被记录，AOF 文件通常比 RDB 文件大。</li><li><strong>恢复速度慢:</strong> 恢复时需要执行所有写操作，时间较长，恢复速度较慢。</li><li><strong>性能问题:</strong> 频繁的写操作以及同步磁盘会影响写性能。</li></ul><h2 id="rdb-和-aof-对比" tabindex="-1">RDB 和 AOF 对比 <a class="header-anchor" href="#rdb-和-aof-对比" aria-label="Permalink to &quot;RDB 和 AOF 对比&quot;">​</a></h2><ul><li><strong>数据恢复精度</strong>：AOF 提供更高的精度，几乎不会丢失数据，而 RDB 只能恢复到最后一次快照生成的状态。</li><li><strong>性能</strong>：AOF 写操作频繁，可能会影响性能，RDB 对性能影响较小。</li><li><strong>文件大小</strong>：AOF 文件通常较大，而 RDB 文件较为紧凑。</li></ul>`,32);function O(a,m,y,_,R,D){const t=o,n=h("ClientOnly");return l(),d("div",null,[f,p(n,null,{default:c(()=>{var i,e;return[(((i=a.$frontmatter)==null?void 0:i.aside)??!0)&&(((e=a.$frontmatter)==null?void 0:e.showArticleMetadata)??!0)?(l(),F(t,{key:0,article:a.$frontmatter},null,8,["article"])):k("",!0)]}),_:1}),b])}const P=r(A,[["render",O]]);export{x as __pageData,P as default};
